---
title: "spatial_epigenomics_tutorial"
output:
  html_document: default
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 72
---

# Tutorial: Spatial epigenomics analysis via DBiT-seq

This tutorial provides a brief introduction to epigenomic analysis of
experiments performed via Deterministic Barcoding in Tissue for Spatial
Omics Sequencing (DBiT-seq). We use the
[ArchR](https://www.archrproject.com/) and
[Seurat](https://satijalab.org/seurat/) packages to create a spatially
resolved analysis object in which epigenetic information is mapped to
the tissue histology. This analysis follows standard scATAC downstream
analysis as outlined in the
[ArchR](https://www.archrproject.com/bookdown/getting-started-with-archr.html)
and [Seurat](https://satijalab.org/seurat/articles/pbmc3k_tutorial)
tutorials.

Here we present the analysis of a [spatial
CUT&Tag](https://www.science.org/doi/10.1126/science.abg7216) experiment
with triplicate mouse brain sections. The sections were profiled with an
antibody against **H3K27ac** (activating enhancers and/or promoters).
Analysis for spatial ATAC-seq experiments use similar code for analysis.
We demonstrate:

-   Creation of an ArchR analysis objects and basic QC
-   Dimensionality reduction and clustering
-   Creation of spatial Seurat objects and spatial QC
-   Analysis of differential gene regulation
-   Peak calling and motif annotation
-   Spatial analysis of genes and motifs
-   Cell typing with spatial mapping

First, we set the working directory to the local tutorial directory and
load required packages.

```{r message=FALSE}

setwd("~/ATX_epigenomics/analysis/") # change to local tutorial directory

library(ArchR)
library(BSgenome.Mmusculus.UCSC.mm10)
library(dplyr)
library(ggpubr)
library(grid)
library(harmony)
library(knitr)
library(magick)
library(Matrix)
library(patchwork)
library(pheatmap)
library(purrr)
library(rmarkdown)
library(Seurat)

source("utils.R")

```

## Set up environment, set global variables

This tutorial assumes you have created fragments files from a epigenomic
alignment and preprocessing pipeline (ie.
[Chromap](https://www.nature.com/articles/s41467-021-26865-w), [Cell
Ranger
ATAC](https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/what-is-cell-ranger-atac)),
and 'spatial' folders via our
[AtlasXBrowser](https://docs.atlasxomics.com/projects/AtlasXbrowser/en/latest/Overview.html)
app. For our custom alignment and preprocessing workflow, see
`fastq2frags/` in this repository.

This tutorial assumes that example data (fragments, spatial folders) is
saved in this repository in the structure described in the README.md of
this directory. To access example data, please contact your AtlasXomics
support scientist or contact
[support\@atlasxomics.com](mailto:support@atlasxomics.com).

Below, we set ArchR global variables, and three character vectors
containing sample info for analysis.

-   addArchRThreads: number of threads to use for parallel processing;
    by default `threads` is set to one half of available threads. ArchR
    [recommends](https://www.archrproject.com/bookdown/getting-set-up.html)
    setting `treads` to 1/2-3/4 total available cores.

-   addArchRGenome: reference genome to be used for gene and genome
    annotations; Archr natively supports **hg19, hg38, mm9,** and
    **mm10** and allows for the creation of custom references. Here we
    use "mm10" (BSgenome.Mmusculus.UCSC.mm10). For more information on
    ArchR reference genomes, see ArchR
    [documentation](https://www.archrproject.com/bookdown/getting-set-up.html).

-   run_ids: identifiers for the runs/experiments included in the
    analysis; here we used standard AtlasXomics run identifiers (ie.
    Dxxxxx_NGxxxxx).

-   fragments_paths: local path to the fragments.tsv.gz files generated
    from a preprocessing and alignment pipeline; this tutorial assumes
    the file paths shown in the README.md.

-   spatial_dirs: local paths to the spatial directories generated by
    AtlasXBrowser. These directories contain images for the tissue ROI,
    run metadata, image scale factors, and a positions file (see below)
    needed to create a Seurat Object; more information on spatial Seurat
    Objects can be found
    [here](https://satijalab.org/seurat/articles/spatial_vignette_2).
    This tutorial assumes the file paths shown in the README.md.

-   position_files: local paths to the `tissue_positions_list.csv` for
    each experiment; these files contain tixel coordinates and on/off
    tissue designations for each tixel.

```{r message=FALSE}

addArchRThreads(threads = 24)
addArchRGenome("mm10")

run_ids <- c(
  "D01208",
  "D01209",
  "D01210"
)

fragment_paths <- c(
  "./fragments/cleaned_D01208_NG02241_fragments.tsv.gz",
  "./fragments/cleaned_D01209_NG02242_fragments.tsv.gz",
  "./fragments/cleaned_D01210_NG02243_fragments.tsv.gz"
)

spatial_dirs <- c(
  "./spatials/D1208/spatial/",
  "./spatials/D1209/spatial/",
  "./spatials/D1210/spatial/"
)

position_files <- c(
  "./spatials/D1208/spatial/tissue_positions_list.csv",
  "./spatials/D1209/spatial/tissue_positions_list.csv",
  "./spatials/D1210/spatial/tissue_positions_list.csv"
)

```

## ArchRProject generation

### Generate Arrow files from fragment files

[Arrow
files](https://www.archrproject.com/bookdown/what-is-an-arrow-file-archrproject.html)
are the basic unit of analysis in ArchR. Arrow files save all sample
data on disk as HDF5 files and are updated with additional layers as
analysis progress. Arrow files are associated together in an
'ArchRProject' which can be accessed by R and stored in memory.

For each sample, an Arrow file is generated from a [fragment
file](https://www.archrproject.com/bookdown/input-file-types-in-archr.html).
Fragment file paths and run ids are supplied to
[createArrowFiles()](https://www.archrproject.com/reference/createArrowFiles.html)
as character vectors. Here, we use fragment.tsv.gz files (typical output
of our pipeline and Cell Ranger ATAC) but BAM files can be used as well.

Parameters `minTSS` and `minFrags` can used to remove low-quality tixels
from analysis. We set minFrags to 0 because we have found tixels with
low fragment counts are removed during on/off-tissue filter (below).

By default, `createArrowFiles()` generates a
[TileMatrix](https://www.archrproject.com/reference/addTileMatrix.html)
(fragment counts per bin per cell) and a
[GeneScoreMatrix](https://www.archrproject.com/bookdown/calculating-gene-scores-in-archr.html)
(computed gene activity per cell) for each sample; here we increase the
size of tiles from 500 to 5000 according to [Deng,
2022](https://www.nature.com/articles/s41586-022-05094-1).

This step can take over 20 minutes, depending on compute resources
available.

```{r message=FALSE, warning=FALSE}

ArrowFiles <- createArrowFiles(
  inputFiles = fragment_paths,
  sampleNames = run_ids,
  minTSS = 2,
  minFrags = 0,
  maxFrags = 1e+07,
  TileMatParams = list(tileSize = 5000),
  force = TRUE
)

```

For each sample, `createArrowFiles` generates [quality control
plots](https://www.archrproject.com/bookdown/per-cell-quality-control.html)
and saves them as PDFs to a `QualityControl` folder in the working
directory.

### Create ArchRProject

ArchR accesses data by associating the Arrow files on disk with an
ArchRProject in memory; all samples are combined into a single
analytical framework.

By default, `ArchRProject()` creates a folder in the working directory
with the name provided by `outputdirectory`; Arrow files, an .rds file
containing the ArchRProject, and other data objects generated during
analysis are saved to this folder.

The ArchRProject can be loaded back into an R session with the
[command](https://www.archrproject.com/reference/loadArchRProject.html)
`loadArchRProject`; the .rds file *must* be named
'Save-ArchR-Project.rds' for the command to work.

```{r message=FALSE}

proj <- ArchRProject(
  ArrowFiles = ArrowFiles,
  outputDirectory = "ArchRProject"
)

```

### Filter "off-tissue" tixels

The
[AtlasXBrowser](https://docs.atlasxomics.com/projects/AtlasXbrowser/en/latest/Overview.html)
app outputs a file named tissue_positions_list.csv. Each row in the file
denotes a tixel barcode with columns denoting row and column indices
(0-49), and on/off tissue designation (1 or 0). This file can be used to
remove tixels that are "off-tissue" from further analysis.

```{r message=FALSE}

all_ontissue <- c()
for (i in seq_along(position_files)) {
  positions <- read.csv(position_files[i], header = FALSE)
  positions$V1 <- paste(run_ids[i], "#", positions$V1, "-1", sep = "")
  on_tissue <- positions$V1 [which(positions$V2 == 1)]
  all_ontissue <- c(all_ontissue, on_tissue)
}
proj <- proj[proj$cellNames %in% all_ontissue]

```

Calling the ArchR project will display summary statistics including the
number of cell/tixels (post-filtering), median TSS, and median fragment
count values.

```{r}

proj

```

### QC plots

Additional QC plots can be generated with ArchR functions; here we plot
Fragment Size distribution and a violin plot of TSS scores for the
samples post-tissue filtering.

```{r}

p1 <- plotFragmentSizes(proj)
p2 <- plotGroups(
  ArchRProj = proj,
  groupBy = "Sample",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  plotAs = "violin",
  alpha = 0.4,
  addBoxPlot = TRUE
)

p1 + p2

```

## Dimensionality reduction and clustering

Here, we perform unbiased clustering of cells and neighborhoods by
similar epigenetic features. Cell types, along with their location in
tissue, can be identified by associating these groups with
well-characterized marker gene(s). Spatial epigenomics can reveal
discreet populations of cells and tissue heterogeneity purely through
epigenetic signatures.

Due to the sparsity of scATAC-seq data, ArchR
[recommends](https://www.archrproject.com/bookdown/dimensionality-reduction-with-archr.html)
using Latent Semantic Indexing (LSI) to first reduce the dimensions of
the insertion count matrix (TileMatrix) described above). The reduced
matrix can then be visualized with a conventional dimensionality
reduction technique (ie. UMAP, t-SNE).

> WARNING: `addIterativeLSI` may error out with traceback pointing to
> missing variable in the `Matrix` or `irlba` packages. To handle these
> bugs, you can uninstall `Matrix` and `irlba` and then re-install from
> source.

 ```         
 renv::purge("Matrix")
 renv::purge("irlba")
 renv::install("Matrix@1.6-1", type = "source")
 renv::install("irlba", type = "source")
 ```
 
> Once the package are re-installed, you must restart your R session.

```{r message=FALSE}

proj <- addIterativeLSI(
  ArchRProj = proj,
  useMatrix = "TileMatrix",
  name = "IterativeLSI",
  iterations = 2,
  clusterParams = list(
    resolution = c(0.5),
    sampleCells = 10000,
    n.start = 10
  ), 
  varFeatures = 50000,
  dimsToUse = 1:30,
  force = TRUE
)

proj <- addHarmony(
  ArchRProj = proj,
  reducedDims = "IterativeLSI",
  name = "Harmony",
  groupBy = "Sample",
  force = TRUE
)

proj <- addClusters(
  input = proj,
  reducedDims = "Harmony",
  method = "Seurat",
  name = "Clusters",
  resolution = c(1.0),
  force = TRUE
)

proj <- addUMAP(
  ArchRProj = proj,
  reducedDims = "Harmony",
  name = "UMAP",
  nNeighbors = 30,
  minDist = 0.0,
  metric = "cosine",
  force = TRUE
)

```

### Plot UMAP and cluster distribution

We can identify unique cell epigenetic signatures by clustering and
identifying the distribution of accessible regulatory elements. This
allows for the analysis of widespread changes to the chromatin that
impact gene regulation based on a cell cluster’s local environment.

Below we plot the UMAP and color by either Sample or cluster identity.

```{r}

# plot the UMAP, colored by sample
p1 <- plotEmbedding(
  ArchRProj = proj,
  colorBy = "cellColData",
  name = "Sample",
  embedding = "UMAP"
)

# plot the UMAP, colored by clusters
p2 <- plotEmbedding(
  ArchRProj = proj,
  colorBy = "cellColData",
  name = "Clusters",
  embedding = "UMAP"
)

p1 + p2

```

Below, we plot the distribution of regulatory elements by distal,
promoter, intronic and exonic regions in each cluster.

```{r}

df1 <- as.data.frame(proj@cellColData)
n_clusters <- length(unique(proj$Clusters))
colors <- ArchRPalettes$stallion[as.character(seq_len(n_clusters))]
names(colors) <- paste0("C", seq_len(n_clusters))

df2 <- df1 %>% group_by(Sample, Clusters) %>%
  summarise(total_count = n(), .groups = "drop") %>%
  as.data.frame()

comp1 <- ggplot(df2, aes(fill = Clusters, y = total_count, x = Sample)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = colors)

comp2 <- ggplot(df2, aes(fill = Sample, y = total_count, x = Clusters)) +
  geom_bar(position = "stack", stat = "identity")

comp3 <- ggplot(df2, aes(fill = Sample, y = total_count, x = Clusters)) +
  geom_bar(position = "fill", stat = "identity")

comp1 + comp2 + comp3

```

It's a good idea to frequently save your ArchRProject, especially after
running expensive computations.

```{r}

saveArchRProject(
  ArchRProj = proj,
  outputDirectory = "ArchRProject",
  load = FALSE
)

```

## SeuratObject visualization

### Build SeuratObjects

To visualize our data spatially, we must create SeuratObjects.

First, we create a new data frame from the ArchRProject cellColData
matrix. This data frame will be used for the `meta.data` parameter of
the `CreateSeuratObject`
[function](https://www.rdocumentation.org/packages/Seurat/versions/3.0.1/topics/CreateSeuratObject).
The cellColData matrix contains the data associated with each tixel. We
convert the name of each tixel to the barcode only (ie.
D01210#AGAGTCAAACATTGGC-1 -\> AGAGTCAAACATTGGC) with a regular
expression, and add a column containing the common log of the fragment
counts.

```{r}

metadata <- getCellColData(proj)
rownames(metadata) <- gsub(".*#|-1", "", row.names(metadata))
metadata$log10_nFrags <- log(metadata$nFrags)

```

Next, we create a gene matrix for the SeuratObject.

```{r}

proj <- addImputeWeights(proj, reducedDims = "Harmony")

gene_matrix <- getMatrixFromProject(
  ArchRProj = proj,
  useMatrix = "GeneScoreMatrix"
)
matrix <- imputeMatrix(
  mat = assay(gene_matrix),
  imputeWeights = getImputeWeights(proj)
)
rownames(matrix) <- gene_matrix@elementMetadata$name

```

Finally, we build the SeuratObjects with `build_atlas_seurat_object()`
from utils.R

```{r}

seurat_objs <- c()
for (i in seq_along(run_ids)) {

  obj <- build_atlas_seurat_object(
    run_id = run_ids[i],
    matrix = matrix,
    metadata = metadata,
    spatial_path = spatial_dirs[i]
  )
  seurat_objs <- c(seurat_objs, obj)
}

```

### Spatial cluster plots

With the SeuratObjects, we can generate a spatial map of the mouse
hippocampus showing the categorization of each tissue region into
distinct clusters, which loosely show the distribution of putative cell
types across the tissue.

Below, we plot the clusters identities of each tixel overlaid on top of
the tissue image with `spatial_plot()` from utils.R; this function calls
the Seurat function
[SpatialDimPlot](https://satijalab.org/seurat/reference/spatialplot).

```{r}

spatial_cluster_plots <- list()
for (i in seq_along(run_ids)){
  plot <- spatial_plot(seurat_objs[[i]], run_ids[i])
  spatial_cluster_plots[[i]] <- plot
}

ggarrange(
  plotlist = spatial_cluster_plots,
  ncol = 3,
  nrow = 1,
  common.legend = TRUE,
  legend = "bottom"
)

```

### Spatial QC plots

Plot qc metrics of each tixel overlaid on top of the tissue image with
`feature_plot()` from utils.R; this function calls the Seurat function
[SpatialFeaturePlot](https://satijalab.org/seurat/reference/spatialplot).
QC metrics to plot include:

-   TSSEnrichment
-   nFrags
-   log10_nFrags

```{r}

metric <- "TSSEnrichment"

spatial_qc_plots <- list()
for (i in seq_along(run_ids)){
  plot <- feature_plot(seurat_objs[[i]], metric, run_ids[i])
  spatial_qc_plots[[i]] <- plot
}

ggarrange(plotlist = spatial_qc_plots, ncol = 3, nrow = 1, legend = "right")

```

### Spatial genes plots

Similar to gene expression levels in a transcriptomic assay, ArchR uses
gene activity scores that incorporate accessibility of both the gene
body and distal regulatory elements are used to rank genes by epigenetic
activity. Combined with spatial information, these scores can be used to
visualize the regulatory landscape of a gene of interest in the original
tissue context.

Here, we create a spatial heatmap of the gene activity score for Opalin,
a marker gene for oligodendrocyte cells, across three spatial H3K27ac
CUT&Tag replicates.

```{r}

gene <- "Opalin"

spatial_gene_plots <- list()
for (i in seq_along(run_ids)){
  plot <- feature_plot(seurat_objs[[i]], gene, run_ids[i])
  spatial_gene_plots[[i]] <- plot
}

ggarrange(plotlist = spatial_gene_plots, ncol = 3, nrow = 1, legend = "right")

```

## Differential gene regulation

### Identify marker genes

Identifying statistically significant gene activity between clusters of
distinct epigenetic signatures can provide a new understanding of the
biological mechanisms underlying tissue morphology.

Below, we extract [gene
scores](https://www.archrproject.com/bookdown/gene-scores-and-marker-genes-with-archr.html)
and identify marker genes with thresholds **FDR \<= 0.05, Log2FC \>=
0.2**. `getMarkerFeatures()` returns a `SummarizedExperiment` object for
downstream analysis; `getMarkers()` converts the `SummarizedExperiment`
to a DataFrame that can be saved for later analysis.

```{r}

markersGS <- getMarkerFeatures(
  ArchRProj = proj,
  useMatrix = "GeneScoreMatrix",
  groupBy = "Clusters",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  testMethod = "wilcoxon"
)

markerList <- getMarkers(markersGS, cutOff = "FDR <= 0.05 & Log2FC >= 0.2")
write.csv(markerList, file = "markerList.csv", row.names = FALSE)

```

### Marker gene heatmaps

A clustered heat map of spatially differentiated gene activity scores
can be used to identify putative cell types. Below, we plot a heatmap of
all marker genes by cluster can be plotted with plotMarkerHeatmap().

```{r}

heatmapGS <- plotMarkerHeatmap(
  seMarker = markersGS,
  cutOff = "FDR <= 0.05 & Log2FC >= 0.2",
  transpose = TRUE,
  labelMarkers = NULL
)

ComplexHeatmap::draw(
  heatmapGS,
  heatmap_legend_side = "bot",
  annotation_legend_side = "bot"
)

```

A subset of markers genes can be plotted as well.

```{r}

marker_genes_subset  <- c(
  "Tmem119", "Cx3cr1", "Itgam", # microglia
  "Slc1a2", "Gfap", # astrocytes
  "Mbp", "Opalin", "Mog", "Mobp", "Cspg4", "Cldn11", "Olig1", #oligodendrocytes
  "Nefh", "Syt1", "Rbfox3", # neurons
  "Slc17a7", # excitatory neuron
  "Gad1", # inhibitory neuron
  "Pdgfrb", "Ng2", # pericyte
  "Prox1" # denate gyrus
)

subsetSE <- markersGS[which(rowData(markersGS)$name %in% marker_genes_subset), ]

heatmapGS_subset <- plotMarkerHeatmap(
  seMarker = subsetSE,
  cutOff = "FDR <= 0.05 & Log2FC >= 0.2",
  transpose = TRUE
)

heatmap(
  as.matrix(heatmapGS_subset@matrix),
  scale = "column",
  col = viridis::viridis(50)
)

```

### Genome tracks of marker genes

Local chromatin accessibility can be plotted against [genome browser
tracks](https://www.archrproject.com/bookdown/track-plotting-with-archrbrowser.html).
Here, we plot all genes in `marker_genes_subset` and save them as PDF in
the ArchRProject/Plots directory.

```{r}

tracks <- plotBrowserTrack(
  ArchRProj = proj,
  groupBy = "Clusters",
  geneSymbol = marker_genes_subset,
  upstream = 50000,
  downstream = 50000
)

# save tracks to pdf
plotPDF(
  tracks,
  ArchRProj = proj,
  length = 6,
  name = "Gene_Tracks",
  addDOC = FALSE
)

```

`grid` can be used to plot specific genes from the list.

Below, we plot the browser track visualizing potential regulatory
elements around the Olig1 gene (a marker for oligodendrocytes). In
spatial ATAC-seq, peaks represent open chromatin; in spatial CUT&Tag,
peaks represent genome regions with a specific histone modification.

```{r}

grid::grid.newpage()
grid::grid.draw(tracks$Olig1)

```

Save your project.

```{r}
saveArchRProject(
  ArchRProj = proj,
  outputDirectory = "ArchRProject",
  load = FALSE
)

```

## Peak Calling

[Pseudo-bulk
replicates](https://www.archrproject.com/bookdown/making-pseudo-bulk-replicates.html)
must be created for clusters before peak calling can be performed; they
are added to the ArchRProject with the `addGroupCoverages()` function.
[Peak
calling](https://www.archrproject.com/bookdown/calling-peaks-w-macs2.html)
is performed with MACS2; specifically, we have found **MACS2 v-2.2.6**
to be compatible with ArchR. The function `findMacs2()` can be used to
find the path to your MACS2 instillation; if this command fails, set
pathToMacs2 to the *absolute* path of your local macs2 installation.

If you get an Error in h5checktypeOrOpenLoc error when running
addGroupCoverages, you may have to set the threads parameter to 1.

We have found that `addReproduciblePeakSet` sometimes fails with a error
message starting
`Error in .safelapply(seq_along(outSummitList), function(i) { :`; if
this occurs, simply restarting the R session (`.rs.restartR()`) and
rerunning the command may solve the issue. This seems to be a bug in
ArchR.

```{r}

proj <- addImputeWeights(proj)

proj <- addGroupCoverages(
  ArchRProj = proj,
  groupBy = "Clusters",
  force = TRUE
)

# Set to local macs2 installation
pathToMacs2 <- "/opt/mamba/envs/jupyterlab/bin/macs2"

proj <- addReproduciblePeakSet(
  ArchRProj = proj,
  groupBy = "Clusters",
  pathToMacs2 = pathToMacs2
)

```

### Plot peak distribution amoung clusters

```{r}

peak_distribution <- proj@peakSet@metadata$PeakCallSummary

comp1_peak <- ggplot(
  peak_distribution,
  aes(fill = Var1, y = Freq, x = Group)
) +
  geom_bar(position = "stack", stat = "identity")

comp1_peak

```

### Identify marker peaks

Extract marker peaks with thresholds FDR \<= 0.05, Log2FC \>= 0.2; save
to a csv for later analysis.

```{r}

proj <- addPeakMatrix(proj)

markersPeaks <- getMarkerFeatures(
  ArchRProj = proj,
  useMatrix = "PeakMatrix", 
  groupBy = "Clusters",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  testMethod = "wilcoxon"
)

markerpeakList <- getMarkers(
  markersPeaks,
  cutOff = "FDR <= 0.05 & Log2FC >= 1"
)

write.csv(
  markerpeakList,
  file = paste0("markerpeakList.csv"),
  row.names = FALSE
)

# Collect data with annotations
peak_data <- data.frame(proj@peakSet@ranges, proj@peakSet@elementMetadata)
total <- merge(peak_data, markerpeakList, by = c("start", "end"))

write.csv(
  total,
  file = paste0("complete_peak_list.csv"),
  row.names = FALSE
)

```

### Plot marker peaks

Create a heatmap of differentially regulated peaks.

```{r}

heatmap_peaks <- plotMarkerHeatmap(
  seMarker = markersPeaks,
  cutOff = "FDR <= 0.05 & Log2FC >= 1",
  transpose = TRUE
)

ComplexHeatmap::draw(
  heatmap_peaks, heatmap_legend_side = "top", show_heatmap_legend = FALSE
)

plotPDF(
  heatmap_peaks,
  name = "peaks_heatmap",
  width = 10,
  length = 6,
  ArchRProj = proj,
  addDOC = FALSE
)

```

## Motif Enrichment

[Motif
annotations](https://www.archrproject.com/bookdown/motif-enrichment-in-differential-peaks.html)
can be added to an ArchRProject with `addMotifAnnotations()`.

```{r}

proj <- addMotifAnnotations(
  ArchRProj = proj,
  motifSet = "cisbp",
  name = "Motif",
  force = TRUE
)

```

### Perform motif enrichment in marker peaks

Compute per-cell deviations across all of our motif annotations using
the `addDeviationsMatrix()` function.

> WARNING: `addDeviationsMatrix` may error out with traceback pointing to
> missing variable in the `Matrix` or `irlba` packages. To handle these
> bugs, you can uninstall `Matrix` and `irlba` and then re-install from
> source.

```         
renv::purge("Matrix")
renv::purge("irlba")
renv::install("Matrix@1.6-1", type = "source")
renv::install("irlba", type = "source")
```

> Once the package are re-installed, you must restart your R session.

```{r}

proj <- addDeviationsMatrix(
  ArchRProj = proj,
  peakAnnotation = "Motif",
  force = TRUE
)

plotVarDev <- getVarDeviations(
  proj,
  name = "MotifMatrix",
  plot = TRUE
)

SampleMotifs <- getMarkerFeatures(
  ArchRProj = proj,
  useMatrix = "MotifMatrix",
  groupBy = "Clusters",
  testMethod = "wilcoxon",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  useSeqnames = "z"
)

enrichMotif <- peakAnnoEnrichment(
  seMarker = markersPeaks,
  ArchRProj = proj,
  peakAnnotation = "Motif",
  cutOff = "FDR <= 0.05 & Log2FC >= 0.1"
)

```

### Plot a heatmap of motifs enriched in marker peaks

Here, we plot the differential regulatory elements associated with each
cluster.

```{r}

heatmapEM <- plotEnrichHeatmap(enrichMotif, n = 7, transpose = TRUE)

plotPDF(
  heatmapEM,
  name = "motifs_heatmap",
  width = 10,
  length = 6,
  ArchRProj = proj,
  addDOC = FALSE
)

```

Save your ArchRProject.

```{r}

saveArchRProject(
  ArchRProj = proj,
  load = FALSE
)

```

## Approximate cell typing

Cell types, along with their location in tissue, can then be identified
by associating these the tissue with well-characterized marker gene(s).

Here, we utilize the Seurat function
[`addModuleScore`](https://satijalab.org/seurat/reference/addmodulescore)
to plot the combined expression of marker genes over tissue. We plot the
oligodendrocyte module score based on a combination of associated marker
genes (Mbp, Opalin, Mog, Mobp, Cspg4, Cldn11).

Marker genes:

-   microglia: "Tmem119", "Cx3cr1", "Itgam"
-   astrocytes: "Slc1a2", "Gfap"
-   oligodendrocytes: "Mbp", "Opalin", "Mog", "Mobp", "Cspg4", "Cldn11",
    "Olig1"
-   neurons: "Nefh", "Syt1", "Rbfox3"
-   excitatory neurons: "Slc17a7"
-   inhibitory neuron: "Gad1"
-   pericyte: "Pdgfrb"
-   denate gyrus: "Prox1"

```{r}

marker_genes <- c("Mbp", "Opalin", "Mog", "Mobp", "Cspg4", "Cldn11", "Olig1")
cell_type <- "oligodendrocytes"

geneset_plots <- list()
for (i in seq_along(run_ids)){
  plot <- geneset_plot(seurat_objs[[i]], marker_genes, cell_type, run_ids[i])
  geneset_plots[[i]] <- plot
}

ggarrange(plotlist = geneset_plots, ncol = 3, nrow = 1, legend = "right")

```
