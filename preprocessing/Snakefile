"""Snakemake pipeline for converting raw fastq data to ATAC-seq fragments
"""

import fnmatch
import os

############################### GLOBALS (CHANGE ME) ##########################

# reference genome
ref_dir = 'refdata-cellranger-arc-GRCh38-2020-A-2.0.0'

# input dir, file extension
inputs_dir = 'inputs'
fastq_ext = '.fastq.gz' 

# working files directory
working_dir = 'working' 

cores = 32 # threads to use
cores_cellRanger = int(cores*0.8) # threads to use in Cell Ranger
mem = 64 # memory to use in Cell Ranger

bbduk_path = 'bbmap/bbduk.sh'
cellranger_path = 'cellranger-atac-2.1.0/cellranger-atac'

############################### WORKFLOW #####################################

samples = os.listdir(inputs_dir)
output = [
  f'{inputs_dir}/{sample}/outs/complete.txt'
  for sample in samples
]

list_fastq={}
for sample in samples:

    # Make dict of fastq files {sample : (r1, r2)}
    list_fastq[sample] = (
      fnmatch.filter(os.listdir(f'{inputs_dir}/{sample}'), f'*1*{fastq_ext}')[0],
      fnmatch.filter(os.listdir(f'{inputs_dir}/{sample}'), f'*2*{fastq_ext}')[0]
    )

    # Make working folders
    working_dir = f'{inputs_dir}/{sample}'
    qc_data = f'{working_dir}/qc_data'
    cr_data = f'{working_dir}/cr_data' # Input fastqs for Cell Ranger


    (os.makedirs(dir) for dir in [working_dir, cr_data, qc_data]
     if not os.path.exists(dir))
            
rule all:
  input:
    output

rule filter_L1:
  input:
    in1 = lambda wildcards: (
      inputs_dir +
      '/{sample}/' +
      list_fastq[wildcards.sample][0]
    ),
    in2 = lambda wildcards: (
      inputs_dir +
      '/{sample}/' +
      list_fastq[wildcards.sample][1]
    )

  output:
    out1 = '{qc_data}/{sample}_linker1_R1.fastq.gz',
    out2 = '{qc_data}/{sample}_linker1_R2.fastq.gz'
  shell:
    '''
    {bbduk_path} \
    in1={input.in1} \
    in2={input.in2} \
    outm1={output.out1} \
    outm2={output.out2} \
    k=30 mm=f rcomp=f restrictleft=103 skipr1=t \
    hdist=3 \
    stats={qc_data}/{wildcards.sample}_stats.linker1.txt \
    threads={cores} \
    literal=GTGGCCGATGTTTCGCATCGGCGTACGACT
    '''

rule filter_L2:
  input:
    in1 = f'{qc_data}' + '/{sample}_linker1_R1.fastq.gz',
    in2 = f'{qc_data}' + '/{sample}_linker1_R2.fastq.gz'
  output:
    out1 = '{qc_data}/{sample}_linker2_R1.fastq.gz',
    out2 = '{qc_data}/{sample}_linker2_R2.fastq.gz'
  shell:
    '''
    {bbduk_path} \
    in1={input.in1} \
    in2={input.in2} \
    outm1={output.out1} \
    outm2={output.out2} \
    k=30 mm=f rcomp=f restrictleft=65 skipr1=t \
    hdist=3 \
    stats={qc_data}/{wildcards.sample}_stats.linker2.txt \
    threads={cores} \
    literal=ATCCACGTGCTTGAGAGGCCAGAGCATTCG
    '''

rule split_r2:
  input:
    f'{qc_data}/{sample}_linker2_R2.fastq.gz'
  output:
    out1 = '{cr_data}/{sample}_S1_L001_R3_001.fastq',
    out2 = '{cr_data}/{sample}_S1_L001_R2_001.fastq'

  shell:
    '''
    python split_r2.py \
    --input {input} \
    --output_R3 {output.out1} \
    --output_R2 {output.out2}
    '''

rule R1_rename: # Needed for snakemake wildcard consistency
  input:
    f'{qc_data}/{sample}_linker2_R1.fastq.gz'
  output:
    '{cr_data}/{sample}_S1_L001_R1_001.fastq.gz'
  shell:
    '''
    cp {input} {output}
    '''

rule cell_ranger:
  input:
    in1 = f'{cr_data}/{sample}_S1_L001_R1_001.fastq.gz',
    in2 = f'{cr_data}/{sample}_S1_L001_R2_001.fastq',
    in3 = f'{cr_data}/{sample}_S1_L001_R3_001.fastq'
  output:
    '{inputs_dir}/{sample}/outs/complete.txt'
  shell:
    '''
    {cellranger_path} count \
    --id={wildcards.sample} \
    --reference={ref_dir} \
    --fastqs={cr_data} \
    --sample={wildcards.sample} \
    --localcores={cores_cellRanger} \
    --localmem={mem} \
    --force-cells=2500
    touch {output}
    '''
